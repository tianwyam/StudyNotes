# 1、缓存





## 1.1、缓存穿透



**缓存穿透**是说收到一个请求，但是该请求缓存中不存在，只能去数据库中查询，然后放进缓存。但当有好多请求同时访问同一个数据时，业务系统把这些请求全发到了数据库；

或者恶意构造一个逻辑上不存在的数据，然后大量发送这个请求，这样每次都会被发送到数据库，最终导致数据库挂掉。



**【解决的办法】：**

对于恶意访问，一种思路是先做校验，对恶意数据直接过滤掉，不要发送至数据库层；

第二种思路是缓存空结果，就是对查询不存在的数据也记录在缓存中，这样就可以有效的减少查询数据库的次数。



## 1.2、缓存击穿



**缓存击穿：**上面提到的某个数据没有，然后好多请求查询数据库，可以归为缓存击穿的范畴：

对于热点数据，当缓存失效的一瞬间，所有的请求都被下放到数据库去请求更新缓存，数据库被压垮。



**【解决的办法】：**

一种思路是加全局锁，就是所有访问某个数据的请求都共享一个锁，获得锁的那个才有资格去访问数据库，其他线程必须等待。但现在大部分系统都是分布式的，本地锁无法控制其他服务器也等待，所以要用到全局锁，比如 Redis的 setnx实现全局锁。

另一种思想是对即将过期的数据进行主动刷新，比如新起一个线程轮询数据，或者比如把所有的数据划分为不同的缓存区间，定期分区间刷新数据。





## 1.3、缓存雪崩



**缓存雪崩**是指当我们给所有的缓存设置了同样的过期时间，当某一时刻，整个缓存的数据全部过期了，然后瞬间所有的请求都被抛向了数据库，数据库就崩掉了。



**【解决的办法】：**解决思路要么是分治，划分更小的缓存区间，按区间过期；要么给每个 key的过期时间加一个随机值，避免同时过期，达到错峰刷新缓存的目的。





## 1.4、缓存预热



新的缓存系统没有任何数据，在缓存重建数据的过程中，系统性能和数据负载都不太好，所以最好在系统上线之前就把缓存的热点数据加载到缓存中，这种缓存预加载手段就是**缓存预热**。



## 1.5、缓存热备



**缓存热备**既当一个缓存服务器不可用时能实时切换到备用缓存服务器，不影响缓存使用。集群模式下，每个主节点都会有一个或多个从节点备用，一旦主节点挂掉，从节点会被哨兵提升为主节点使用。





----



# 2、案例



## 2.1、Redis挂掉

对于 Redis 挂掉了，请求全部走数据库，也属于**缓存雪崩**，我们可以有以下思路进行解决：

- **事发前：**实现 Redis 的高可用（主从架构+Sentinel 或者 Redis Cluster），尽可能避免 Redis 挂掉这种情况。
- **事发中：**万一 Redis 真的挂了，我们可以设置本地缓存（ehcache）+ 限流（hystrix），尽量避免我们的数据库被干掉。
- **事发后：**Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。









